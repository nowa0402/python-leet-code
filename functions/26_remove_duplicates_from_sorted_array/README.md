
# Remove Duplicates from Sorted Array

## **ソート済み配列の重複を削除（in-place）**

### **問題**

与えられた整数配列 `nums` は**昇順（non-decreasing order）**にソートされています。  
この配列から**重複を削除し**、各要素が**一度だけ**現れるようにしてください。  
**要素の相対的な順序は変えずに**、`nums` を**その場で（in-place）**変更してください。  

その後、**`nums` 内の一意な要素の個数 `k` を返してください。**

---

### **実装条件**

1. `nums` の最初の `k` 個の要素に**重複なしの値を順番通り配置**する。  
2. `nums[k]` 以降の部分は不要なので、何が入っていてもよい。  
3. `k` を返す。  

**カスタムジャッジ（テスト）**  

ジャッジは次のコードで解答を検証します:

```java
int[] nums = [...]; // 入力配列
int[] expectedNums = [...]; // 正しい長さの期待される配列

int k = removeDuplicates(nums); // 関数を呼び出し

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

すべての assert が通れば、解答は正しいと判定されます。

## 例

### 例 1

入力:
nums = [1,1,2]

出力:
2, nums = [1,2,_]

説明:
関数は k = 2 を返し、nums の最初の 2 要素は [1, 2] になります。
k 以降の要素は重要ではないため_ で表記。

### 例 2

入力:
nums = [0,0,1,1,1,2,2,3,3,4]

出力:
5, nums = [0,1,2,3,4,_,_,_,_,_]

説明:
関数は k = 5 を返し、nums の最初の 5 要素は [0,1,2,3,4] になります。
k 以降の要素は_ で表記。

## 制約

- 1 <= nums.length <= 3 × 10⁴
- -100 <= nums[i] <= 100
- nums は**昇順（non-decreasing order）**にソートされている
